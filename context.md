# 执行上下文（context）：执行代码的基础---js代码执行和解析的所在的环境的抽象概念，又分为
 全局执行上下文（堆，存放在执行栈的是指针地址），函数执行上下文(栈)
 1.创建变量对象，首先初始化函数的参数arguments，提升函数声明还有变量声明
 2.确定作用域（），形成作用域链（从当前作用域开始一层一层向上查找一个变量，
 直到找到全局都没有发现，就返回not defined,这种一层一层上查找的规则，就叫作用域链）
 3.确定this指向

# 执行上下文和作用域的关系
 作用域是在函数定义的时候就确定的，是静态的，执行上下文（this）是函数的调用关系，是动态的
 执行上下文是用来维护代码执行所需要的变量，this指向等，作用域是规定了如何查找变量，也就是
 确定当前执行代码对变量的访问权限，执行上下文中变量生效的范围。js作用域是在函数定义的时候就确定的,可以把作用域看成执行上下文中代码对变量的访问权限
 全局作用域  函数作用域

# 执行栈（多个执行上下文存放的栈,v8编译的时候创建）
 当js代码开始运行的时候，会创建一个全局执行的上下文，并且push到执行栈中，每当函数调用，都会为该函数创建一个函数上下文，并且push到执行栈的栈顶，等到栈顶的函数运行完成之后，这个函数上下文会被pop出执行栈，并且把执行栈的控制权移动到下一个执行上下文

 this 是跟上下文绑定的，所以分为两种，全局上下文中的this，函数上下文的this,
 1.全局上下文的this指向window
 2.函数上下文的this是谁调用指向谁
 严格模式下指向undefine，在es6 class中，函数会默认加上严格模式，所以指向undefined需要this.xxx = this.xxx.bind(this)

 箭头函数this指向是继承外层作用域的this
 箭头函数不能用来当作构造函数
 箭头函数不能用来定义事件的回调函数，因为箭头函数在定义的时候就绑定了上下文，所以这种动态click事件绑定上下文的就没有意义
 不用用来定义原型方法，原型方法的this应该指向实例对象
 用来作为对象的方法，因为也不能指向对象

# 变量提升
 通俗的讲就是把变量声明和函数声明提升到当前作用域顶部，并且对变量声明初始化为undefined 对函数声明赋值为函数引用。实际上变量的
 位置是没有变得，底层是v8编译js代码的时候会生成执行上下文 里面包含变量环境，变量环境的对象就包含了函数
 声明和变量声明，js编译代码的时候发现了变量声明就在环境对象中创建了一个属性，undefined，发现函数声明就把
 函数定义存放在堆里面 同时在对象中创建一个属性 指向堆里面函数地址引用。所以在执行的时候，遇到变量或者函数调用就会去变量对象中查找

 let const会存放在词法环境 ，块级作用域内部的会存放在词法环境里面从新开辟的栈里面 ，先查找词法环境再查找变量环境，let 初始化被提升，
 赋值undefined没有。就会存在暂时性死区，所以在let声明的变量前使用会报 before initialzation

 作用域链是怎么实现的 ，是在每个执行上下文的变量环境中，都包含了一个外部引用outer，在查找变量的时候，先在当前上下文中查找，找不到会在outer所指向的上下文中查找

词法作用域，为什么一个函数内部调用外部的函数，这个外部的函数所指向的外部上下文outer不是这个函数，而是全局上下文，词法作用域，
 指作用域是由代码中函数声明的位置决定的，所以词法作用域是静态的，在编译的时候就确定了

 ```js
var o1 = {
  a:1
}
var o2 = {
  a:2
}
function fuc(){
  console.log(this.a)
}
( fuc.bind(o1).bind(o2) )() // 1 
 ```