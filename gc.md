## 垃圾回收（手动回收，自动回收）
js是自动，回收垃圾数据，在js里面，数据存放在堆内存和栈内存中，基本数据类型以及函数上下文的数据存放到栈内存，引用数据类型存放在堆内存里面，栈内存的数据会在上下文执行完成通过移动esp指针完成回收垃圾数据
所以我们需要重点关注的是堆内存的垃圾回收，数据有一直使用存在的全局变量，也有短暂存在的使用一次的变量，对这些数据采用
一样的垃圾回收算法肯定不是最优的，所以v8为了执行垃圾回收，把堆内存分为新生代老生代两块内存区域，
新生代：存放生存时间短的对象（1-8M）
老生代：存放生存时间久的对象
然后用副垃圾回收器处理新生代，主垃圾回收器处理老生代
垃圾回收的步骤
1.找到活动对象和非活动对象（垃圾数据），全局遍历，能够找到的数据就标记活动对象，找不到的标记会非活动对象
2.清除非活动对象
3.整理内存区域，因为清除之后会存在很多内存碎片，不整理在需要分配一个连续的内存空间的时候就会出现内存不足的提示

副垃圾回收器用的算法是分为 活动和空闲两块区域，新加入的对象都放在活动区域，当活动区域快被填满的时候，就执行一次
垃圾清理操作，先标记，标记完成后把活动对象复制到空闲区域同时有序的排列起来，这样就不会存在内存碎片了，完成复制
后，把活动区域和空闲区域互换，这样就完成了新生代的垃圾回收

主垃圾回收器因为里面存放的数据大多比较大，复制的会花费比较多的时间，所以采用的是标记-清除算法+标记-整理算法

# v8对垃圾回收有哪些优化方案（主线程执行以及执行一次完整的垃圾回收导致主线程卡顿）
1.副垃圾回收器在清除的时候，发现一个变量在执行两次垃圾回收都没有被清除，就会移动到老生代里面，这样保证了新生代内存空间

因为js是允许在主线程之上的，所以一旦执行垃圾回收，就需要暂停js脚本，这种垃圾回收的方式被称为全停顿回收
v8 主要采用并行 并发 增量标记来优化垃圾回收的
1.将一个完整的垃圾回收任务拆分为多个小的垃圾回收任务
2.将辅助功能，比如标记对象，移动对象用后台线程进行，这样就会减少主线程卡顿的时间

# 并行怎么理解
用多个用多个辅助线程来处理垃圾回收，这样就加快了垃圾回收的速度，但是也还是全停顿的方式，因为副垃圾回收器处理的新生代存放的数据都比较小，全停顿对用户感知不明显，所以主要使用是用到副垃圾回收器

# 增量标记怎么实现
要实现增量标记需要能暂停，在重新开始的时候还能找到上次清除到的节点，所以v8采用了三色标记法，黑色表示标记完成，白色表示
没有访问到，灰色代表目前正在处理的节点，下次进行垃圾回收任务的时候找到灰色节点开始回收就可以了

# 并发怎么理解
主线程在执行js脚本的过程中，辅助线程能够在后台完成垃圾回收的操纵，这样就不会阻塞主线程了
问题
1.主线程执行js脚本的时候，堆内存的内容随时可能发生变化，所以可能导致辅助线程完成的垃圾回收工作无效
2.主线程和辅助线程可能同时去更改一个对象

但是权衡了全停顿和并发的利弊之后，v8还是采用了并发来执行垃圾回收，用优先级来处理并发存在的问题。增量标记也是并发的

主垃圾回收器同时采用了三种优化策略

# 内存泄漏
原因由于scope以及闭包特性的不了解 导致隐式数据持有没有被及时释放，当访问量过大或者时间过久导致内存泄漏

怎么判断 使用chrome的Performance面板，观察内存变化，如果多次gc(垃圾回收)后，整体趋势还是向上的，就存在内存泄漏的可能

1.避免循环引用
2.避免绑定到全局变量
```js
function foo(){
  this.arr = new Array(20000)
}
```
即使foo函数执行完了。arr被window对象引用了，所以会一直存在内存里面
3.闭包
```js
function foo(){
  let obj = {}
  obj.x = '123'
  obj.y = '345'
  return function (){
    console.log(obj.x)
  }
}
// 只使用一个x属性却要保存整个obj对象，所以在闭包中不需要引用的数据就不要引用
function foo(){
  let obj = {}
  obj.x = '123'
  obj.y = '345'
  let temp = obj.x
  return function (){
    console.log(temp)
  }
}
```
4.引用dom节点导致，只有同时满足dom树和js代码都不引用某个dom，该dom节点才会被回收，所以保存dom需要注意

# 频繁的垃圾回收
函数里面的引用数据类型存放在堆内存,频繁创建这个临时变量会导致新生代很快就要执行垃圾清理
```js
 function fuc(str){
   let arr = new Array(str.length)
 }
 function foo(){
   for(let i = 0; i<100000;i++){
     fuc('123')
   }
 }
 foo()
 // 需要频繁使用的临时变量可以考虑使用全局变量或者在初始函数里面定义传入进去
 function fuc(str,a){
  //  let arr = new Array(str.length)
   return arr
 }
 function foo(){
   let a = []
   for(let i = 0; i<100000;i++){
     fuc('123',a)
   }
 }
 foo()
```

# Map 键值对的数据集合
解决Object的key必须是string,有序
```js
var map = new Map()
map.set(123,'s') // 键值对
map.get(123)
map.has(123)
```

# set 唯一值的集合
```js
var set = new Set(123) 
set.add()
set.has()
```

# WeakMap 和 WeakSet、
解决map的内存管理问题
```js
var map = new Map()
var weakMap = new WeakMap()
(function fuc(){
  var k1 = {x:1}
  var k2 = {x:2}
  map.set(k1,'k1')
  weakMap.set(k2,'k2')
})()
map.forEach((val,key)=>console.log(val,key))
weakMap.forEach((val,key)=>console.log(val,key))

var arr = [];
var weakmap = new WeakMap();

(function fuc(){
  var k1 = {x: 1};
  var k2 = {y: 2};
  arr[0] = k1;
  arr[1] = k2
})()

map.forEach((val, key) => console.log(key, val))
```
按道理执行完函数之后要把上下文清空以及把变量回收掉，但是还是能在外面访问到map里面的k1,k2属性这两个对象，时间一长也有可能导致内存溢出map通过维持两个数组，一个存放key,一个存放value，然后一一对应，即使引用以及离开作用域了，数组也还是会一直保存这个引用，导致垃圾无法回收，
WeakMap 直接是在对象上面添加这个属性，
```js
WeakMap.prototype = {
  set:Object.defineProperty(key,this.name,{ // 所以key必须是Object
    value:[key,value]
  }),
  get:xxxx
}
```
WeakMap持有的只是每个键值对的“弱引用”，不会额外开内存保存键值引用,所以执行结束对象被回收，他上面也就不存在这个属性了，因为他随时可能被清除，所以没有foreach，keys,entires方法
用来做缓存，获取之后清空


